# coding: utf-8

"""
    candlepin-rpc-api

    RPC-ish interface for candlepin.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class SubscriptionsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def attach(self, **kwargs):  # noqa: E501
        """Attaches one or more subscription pools to the system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param list[str] pool: Gives the ID for the subscriptions pool (collection of products) to attach to the system.
        :param int quantity: Attaches a specified number of subscriptions to the system. Subscriptions may have certain limits on them, like the number of sockets on the system or the number of allowed virtual guests. It is possible to attach multiple subscriptions (or stacking subscriptions) to cover the number of sockets, guests, or other characteristics. May not be used with an auto-attach.
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.attach_with_http_info(**kwargs)  # noqa: E501
            return data

    def attach_with_http_info(self, **kwargs):  # noqa: E501
        """Attaches one or more subscription pools to the system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param list[str] pool: Gives the ID for the subscriptions pool (collection of products) to attach to the system.
        :param int quantity: Attaches a specified number of subscriptions to the system. Subscriptions may have certain limits on them, like the number of sockets on the system or the number of allowed virtual guests. It is possible to attach multiple subscriptions (or stacking subscriptions) to cover the number of sockets, guests, or other characteristics. May not be used with an auto-attach.
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id', 'pool', 'quantity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501
        if 'pool' in params:
            query_params.append(('pool', params['pool']))  # noqa: E501
            collection_formats['pool'] = 'multi'  # noqa: E501
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/attach', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SyncResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def autoattach(self, **kwargs):  # noqa: E501
        """Automatically attaches the best-matched compatible subscription or subscriptions to the system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.autoattach(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str servicelevel: Sets the preferred service level to use with subscriptions automatically attached to the system. Service levels are commonly premium, standard, and none, though other levels may be available depending on the product and the contract.
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.autoattach_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.autoattach_with_http_info(**kwargs)  # noqa: E501
            return data

    def autoattach_with_http_info(self, **kwargs):  # noqa: E501
        """Automatically attaches the best-matched compatible subscription or subscriptions to the system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.autoattach_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str servicelevel: Sets the preferred service level to use with subscriptions automatically attached to the system. Service levels are commonly premium, standard, and none, though other levels may be available depending on the product and the contract.
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id', 'servicelevel']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method autoattach" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501
        if 'servicelevel' in params:
            query_params.append(('servicelevel', params['servicelevel']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/autoattach', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SyncResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_status(self, **kwargs):  # noqa: E501
        """Displays shows the current status of the products and attached subscriptions for the system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :return: SubscriptionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_status_with_http_info(self, **kwargs):  # noqa: E501
        """Displays shows the current status of the products and attached subscriptions for the system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :return: SubscriptionStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/get_status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubscriptionStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_pool_ids(self, **kwargs):  # noqa: E501
        """Lists all of the subscriptions that are compatible with a system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_pool_ids(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str afterdate: Shows pools that are active on or after the given date.
        :param bool all: Lists all possible subscriptions that have been purchased, even if they don't match the architecture of the system.
        :param bool available: Lists available subscriptions which are not yet attached to the system.
        :param bool consumed: Lists all of the subscriptions currently attached to the system.
        :param str ondate: Sets the date to use to search for active and available subscriptions. The default (if not explicitly passed) is today's date; using a later date looks for subscriptions which will be active then. This is only used with the --available option.
        :param bool nooverlap: Shows pools which provide products that are not already covered.
        :param bool matchinstalled: Shows only subscriptions matching products that are currently installed; only used with --available option.
        :param str matches: Limits to only subscriptions or products which contain SEARCH in the subscription or product information, varying with the list requested and the server version. SEARCH may contain the wildcards ? or * to match a single character or zero or more characters, respectively. The wildcard characters may be escaped with a backslash to represent a literal question mark or asterisk. Likewise, to represent a backslash, it must be escaped with another backslash.
        :return: ListPoolIdsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_pool_ids_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_pool_ids_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_pool_ids_with_http_info(self, **kwargs):  # noqa: E501
        """Lists all of the subscriptions that are compatible with a system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_pool_ids_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str afterdate: Shows pools that are active on or after the given date.
        :param bool all: Lists all possible subscriptions that have been purchased, even if they don't match the architecture of the system.
        :param bool available: Lists available subscriptions which are not yet attached to the system.
        :param bool consumed: Lists all of the subscriptions currently attached to the system.
        :param str ondate: Sets the date to use to search for active and available subscriptions. The default (if not explicitly passed) is today's date; using a later date looks for subscriptions which will be active then. This is only used with the --available option.
        :param bool nooverlap: Shows pools which provide products that are not already covered.
        :param bool matchinstalled: Shows only subscriptions matching products that are currently installed; only used with --available option.
        :param str matches: Limits to only subscriptions or products which contain SEARCH in the subscription or product information, varying with the list requested and the server version. SEARCH may contain the wildcards ? or * to match a single character or zero or more characters, respectively. The wildcard characters may be escaped with a backslash to represent a literal question mark or asterisk. Likewise, to represent a backslash, it must be escaped with another backslash.
        :return: ListPoolIdsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id', 'afterdate', 'all', 'available', 'consumed', 'ondate', 'nooverlap', 'matchinstalled', 'matches']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_pool_ids" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501
        if 'afterdate' in params:
            query_params.append(('afterdate', params['afterdate']))  # noqa: E501
        if 'all' in params:
            query_params.append(('all', params['all']))  # noqa: E501
        if 'available' in params:
            query_params.append(('available', params['available']))  # noqa: E501
        if 'consumed' in params:
            query_params.append(('consumed', params['consumed']))  # noqa: E501
        if 'ondate' in params:
            query_params.append(('ondate', params['ondate']))  # noqa: E501
        if 'nooverlap' in params:
            query_params.append(('nooverlap', params['nooverlap']))  # noqa: E501
        if 'matchinstalled' in params:
            query_params.append(('matchinstalled', params['matchinstalled']))  # noqa: E501
        if 'matches' in params:
            query_params.append(('matches', params['matches']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/list_pool_ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListPoolIdsResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_subscriptions(self, **kwargs):  # noqa: E501
        """Lists all of the subscriptions that are compatible with a system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_subscriptions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str afterdate: Shows pools that are active on or after the given date.
        :param bool all: Lists all possible subscriptions that have been purchased, even if they don't match the architecture of the system.
        :param bool available: Lists available subscriptions which are not yet attached to the system.
        :param bool consumed: Lists all of the subscriptions currently attached to the system.
        :param str ondate: Sets the date to use to search for active and available subscriptions. The default (if not explicitly passed) is today's date; using a later date looks for subscriptions which will be active then. This is only used with the --available option.
        :param bool nooverlap: Shows pools which provide products that are not already covered.
        :param bool matchinstalled: Shows only subscriptions matching products that are currently installed; only used with --available option.
        :param str matches: Limits to only subscriptions or products which contain SEARCH in the subscription or product information, varying with the list requested and the server version. SEARCH may contain the wildcards ? or * to match a single character or zero or more characters, respectively. The wildcard characters may be escaped with a backslash to represent a literal question mark or asterisk. Likewise, to represent a backslash, it must be escaped with another backslash.
        :return: ListPoolsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_subscriptions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_subscriptions_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_subscriptions_with_http_info(self, **kwargs):  # noqa: E501
        """Lists all of the subscriptions that are compatible with a system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_subscriptions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str afterdate: Shows pools that are active on or after the given date.
        :param bool all: Lists all possible subscriptions that have been purchased, even if they don't match the architecture of the system.
        :param bool available: Lists available subscriptions which are not yet attached to the system.
        :param bool consumed: Lists all of the subscriptions currently attached to the system.
        :param str ondate: Sets the date to use to search for active and available subscriptions. The default (if not explicitly passed) is today's date; using a later date looks for subscriptions which will be active then. This is only used with the --available option.
        :param bool nooverlap: Shows pools which provide products that are not already covered.
        :param bool matchinstalled: Shows only subscriptions matching products that are currently installed; only used with --available option.
        :param str matches: Limits to only subscriptions or products which contain SEARCH in the subscription or product information, varying with the list requested and the server version. SEARCH may contain the wildcards ? or * to match a single character or zero or more characters, respectively. The wildcard characters may be escaped with a backslash to represent a literal question mark or asterisk. Likewise, to represent a backslash, it must be escaped with another backslash.
        :return: ListPoolsResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id', 'afterdate', 'all', 'available', 'consumed', 'ondate', 'nooverlap', 'matchinstalled', 'matches']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_subscriptions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501
        if 'afterdate' in params:
            query_params.append(('afterdate', params['afterdate']))  # noqa: E501
        if 'all' in params:
            query_params.append(('all', params['all']))  # noqa: E501
        if 'available' in params:
            query_params.append(('available', params['available']))  # noqa: E501
        if 'consumed' in params:
            query_params.append(('consumed', params['consumed']))  # noqa: E501
        if 'ondate' in params:
            query_params.append(('ondate', params['ondate']))  # noqa: E501
        if 'nooverlap' in params:
            query_params.append(('nooverlap', params['nooverlap']))  # noqa: E501
        if 'matchinstalled' in params:
            query_params.append(('matchinstalled', params['matchinstalled']))  # noqa: E501
        if 'matches' in params:
            query_params.append(('matches', params['matches']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/list_subscriptions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListPoolsResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def redeem(self, **kwargs):  # noqa: E501
        """Redeems subscription for systems purchased from third-party vendors that include a subscription.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redeem(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str email: Gives the email account to send the redemption notification message to.
        :param str locale: Sets the locale to use for the message. If none is given, then it defaults to the local system's locale.
        :param str org: Identifies the organization which issued the subscription being redeemed.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.redeem_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.redeem_with_http_info(**kwargs)  # noqa: E501
            return data

    def redeem_with_http_info(self, **kwargs):  # noqa: E501
        """Redeems subscription for systems purchased from third-party vendors that include a subscription.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redeem_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str email: Gives the email account to send the redemption notification message to.
        :param str locale: Sets the locale to use for the message. If none is given, then it defaults to the local system's locale.
        :param str org: Identifies the organization which issued the subscription being redeemed.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id', 'email', 'locale', 'org']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redeem" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'org' in params:
            query_params.append(('org', params['org']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/redeem', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh(self, **kwargs):  # noqa: E501
        """Pulls the latest subscription data from the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str last_state_token: Opaque token that server uses to track whether it needs to send updated state.
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.refresh_with_http_info(**kwargs)  # noqa: E501
            return data

    def refresh_with_http_info(self, **kwargs):  # noqa: E501
        """Pulls the latest subscription data from the server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param str last_state_token: Opaque token that server uses to track whether it needs to send updated state.
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id', 'last_state_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501
        if 'last_state_token' in params:
            query_params.append(('last_state_token', params['last_state_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/refresh', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SyncResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove(self, **kwargs):  # noqa: E501
        """Removes a subscription from the system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param list[str] serial: Gives the serial number of the subscription certificate for the specific product to remove from the system. Subscription certificates attached to a system are in a certificate, in /etc/pki/entitlement/<serial_number>.pem.
        :param list[str] pool: Removes all subscription certificates for the specified pool id from the system.
        :param bool all: Removes all of the subscriptions attached to a system.
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remove_with_http_info(**kwargs)  # noqa: E501
            return data

    def remove_with_http_info(self, **kwargs):  # noqa: E501
        """Removes a subscription from the system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :param list[str] serial: Gives the serial number of the subscription certificate for the specific product to remove from the system. Subscription certificates attached to a system are in a certificate, in /etc/pki/entitlement/<serial_number>.pem.
        :param list[str] pool: Removes all subscription certificates for the specified pool id from the system.
        :param bool all: Removes all of the subscriptions attached to a system.
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id', 'serial', 'pool', 'all']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501
        if 'serial' in params:
            query_params.append(('serial', params['serial']))  # noqa: E501
            collection_formats['serial'] = 'multi'  # noqa: E501
        if 'pool' in params:
            query_params.append(('pool', params['pool']))  # noqa: E501
            collection_formats['pool'] = 'multi'  # noqa: E501
        if 'all' in params:
            query_params.append(('all', params['all']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/remove', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SyncResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
