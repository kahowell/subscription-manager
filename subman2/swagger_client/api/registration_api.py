# coding: utf-8

"""
    candlepin-rpc-api

    RPC-ish interface for candlepin.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class RegistrationApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def regenerate_identity(self, **kwargs):  # noqa: E501
        """Requests that the subscription management service issue a new identity certificate for the system, using an existing UUID in the original identity certificate.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.regenerate_identity(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.regenerate_identity_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.regenerate_identity_with_http_info(**kwargs)  # noqa: E501
            return data

    def regenerate_identity_with_http_info(self, **kwargs):  # noqa: E501
        """Requests that the subscription management service issue a new identity certificate for the system, using an existing UUID in the original identity certificate.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.regenerate_identity_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method regenerate_identity" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth', 'certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/regenerate_identity', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SyncResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register(self, **kwargs):  # noqa: E501
        """Registers a new system to the subscription management service.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SystemProfile body: system profile, including facts and installed products
        :param str name: Sets the name of the system to register. This defaults to the hostname.
        :param str consumerid: References an existing system inventory ID to resume using a previous registration for this system. The ID is used as an inventory number for the system in the subscription management service database. If the system's identity is lost or corrupted, this option allows it to resume using its previous identity and subscriptions.
        :param list[str] activationkey: Gives a comma-separated list of product keys to use to redeem or apply specific subscriptions to the system. This is used for preconfigured systems which may already have products installed. Activation keys are issued by an on-premise subscription management service, such as Subscription Asset Manager. When the activationkey option is used, it is not necessary to use the username and password options, because the authentication information is implicit in the activation key.
        :param bool autoattach: Automatically attaches compatible subscriptions to this system.
        :param str servicelevel: Sets the preferred service level to use with subscriptions added to the system. Service levels are commonly premium, standard, and none, though other levels may be available depending on the product and the contract.
        :param str org: Assigns the system to an organization. Infrastructures which are managed on-site may be multi-tenant, meaning that there are multiple organizations within one customer unit. A system may be assigned manually to one of these organizations.  When a system is registered with the Customer Portal, this is not required. When a system is registered with an on-premise application such as Subscription Asset Manager, this argument is required, unless there is only a single organization configured.
        :param str environment: Registers the system to an environment within an organization.
        :param str release: Release version to use during registration
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.register_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.register_with_http_info(**kwargs)  # noqa: E501
            return data

    def register_with_http_info(self, **kwargs):  # noqa: E501
        """Registers a new system to the subscription management service.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SystemProfile body: system profile, including facts and installed products
        :param str name: Sets the name of the system to register. This defaults to the hostname.
        :param str consumerid: References an existing system inventory ID to resume using a previous registration for this system. The ID is used as an inventory number for the system in the subscription management service database. If the system's identity is lost or corrupted, this option allows it to resume using its previous identity and subscriptions.
        :param list[str] activationkey: Gives a comma-separated list of product keys to use to redeem or apply specific subscriptions to the system. This is used for preconfigured systems which may already have products installed. Activation keys are issued by an on-premise subscription management service, such as Subscription Asset Manager. When the activationkey option is used, it is not necessary to use the username and password options, because the authentication information is implicit in the activation key.
        :param bool autoattach: Automatically attaches compatible subscriptions to this system.
        :param str servicelevel: Sets the preferred service level to use with subscriptions added to the system. Service levels are commonly premium, standard, and none, though other levels may be available depending on the product and the contract.
        :param str org: Assigns the system to an organization. Infrastructures which are managed on-site may be multi-tenant, meaning that there are multiple organizations within one customer unit. A system may be assigned manually to one of these organizations.  When a system is registered with the Customer Portal, this is not required. When a system is registered with an on-premise application such as Subscription Asset Manager, this argument is required, unless there is only a single organization configured.
        :param str environment: Registers the system to an environment within an organization.
        :param str release: Release version to use during registration
        :return: SyncResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'name', 'consumerid', 'activationkey', 'autoattach', 'servicelevel', 'org', 'environment', 'release']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'consumerid' in params:
            query_params.append(('consumerid', params['consumerid']))  # noqa: E501
        if 'activationkey' in params:
            query_params.append(('activationkey', params['activationkey']))  # noqa: E501
            collection_formats['activationkey'] = 'multi'  # noqa: E501
        if 'autoattach' in params:
            query_params.append(('autoattach', params['autoattach']))  # noqa: E501
        if 'servicelevel' in params:
            query_params.append(('servicelevel', params['servicelevel']))  # noqa: E501
        if 'org' in params:
            query_params.append(('org', params['org']))  # noqa: E501
        if 'environment' in params:
            query_params.append(('environment', params['environment']))  # noqa: E501
        if 'release' in params:
            query_params.append(('release', params['release']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/register', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SyncResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unregister(self, **kwargs):  # noqa: E501
        """Removes a system's subscriptions and removes it from the subscription management service.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unregister(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unregister_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.unregister_with_http_info(**kwargs)  # noqa: E501
            return data

    def unregister_with_http_info(self, **kwargs):  # noqa: E501
        """Removes a system's subscriptions and removes it from the subscription management service.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unregister_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str consumer_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['consumer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unregister" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'consumer_id' in params:
            query_params.append(('consumer_id', params['consumer_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.api+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['certAuth']  # noqa: E501

        return self.api_client.call_api(
            '/operations/unregister', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
